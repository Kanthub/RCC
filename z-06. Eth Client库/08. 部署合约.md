## 部署合约

__利用 abigen 生成的 go代码 里的部署方法 部署合约__

**前提准备：**


使用 nodejs，安装 solc 工具：

```go
npm install -g solc
```

使用命令，编译合约代码，会在当目录下生成一个编译好的二进制字节码文件 store_sol_Store.bin：

```go
solcjs --bin Store.sol
```

使用命令，生成合约 abi 文件，会在当目录下生成 store_sol_Store.abi 文件：

```go
solcjs --abi Store.sol
```

abigin 工具可以使用下面的命令安装：

```go
go install github.com/ethereum/go-ethereum/cmd/abigen@latest
```

使用 abigen 工具根据这两个生成 bin 文件和 abi 文件，生成 go 代码：

```go
abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=store.go
```

**部署代码：**

```go
package main

import (
	"context"
	"fmt"
	"log"

	"crypto/ecdsa"
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/test/init_project/store" // 替换为你的合约包路径
)

func main() {

	// 连接到以太坊节点
	client, err := ethclient.Dial("wss://eth-sepolia.g.alchemy.com/v2/Sr-jePEX8IwI4T--VH5xju9OEHopQfut")
	if err != nil {
		log.Fatal(err)
	}

	// 获得私钥
	privateKey, err := crypto.HexToECDSA("245863ca6ac270f4e3e9f60c294779d0355070aa2d4cf4444ebd19635f784cf9")
	if err != nil {
		log.Fatal(err)
	}

	// 获得公钥和地址
	publicKey := privateKey.Public()
	publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
	if !ok {
		log.Fatal("cannot assert type: publicKey is not of type *ecdsa.PublicKey")
	}
	fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)

	// 获得地址的nonce
	nonce, err := client.PendingNonceAt(context.Background(), fromAddress)
	if err != nil {
		log.Fatal(err)
	}

	// 通过节点获得chainID和gasPrice
	chainID, err := client.NetworkID(context.Background())
	if err != nil {
		log.Fatal(err)
	}
	// gasPrice, err := client.SuggestGasPrice(context.Background())
	// if err != nil {
	// 	log.Fatal(err)
	// }

	// 创建一个“交易签名者”（Transactor）
	// 它是一个工具，帮你把私钥和链 ID（Chain ID）绑定在一起，生成一个可以签名的交易对象
	// 它会自动处理 EIP155 签名
	// auth 后面会被用来部署一个叫 store 的智能合约，所以它就像一个“盖好章的授权书”，
	// 告诉区块链：“这是我签名的交易，照着执行吧！”
	auth, err := bind.NewKeyedTransactorWithChainID(privateKey, chainID)
	if err != nil {
		log.Fatal(err)
	}
	// 设置 gasLimit 和 gasPrice
	auth.GasLimit = uint64(3000000)         // in units
	auth.GasPrice = big.NewInt(20000000000) // in wei
	auth.Nonce = big.NewInt(int64(nonce))
	auth.Value = big.NewInt(0)

	// 部署合约
	input := "1.0"
	address, tx, instance, err := store.DeployStore(auth, client, input)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println("Contract Address: ", address.Hex())
	fmt.Println("Transaction Hash: ", tx.Hash().Hex())

	_ = instance
}

```
