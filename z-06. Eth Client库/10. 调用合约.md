## 调用合约

**1. 使用 abigen 生成的 Go 合约代码 来调用合约函数**

若调用函数改变区块链状态，需传入一个交易管理者
（bind.NewKeyedTransactorWithChainID(privateKey, chainID))

若调用函数只读区块链，需传入一个&bind.CallOpts{}

```go
package main

import (
    "context"
    "fmt"
    "log"
    "math/big"

    "github.com/ethereum/go-ethereum/accounts/abi/bind"
    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/crypto"
    "github.com/ethereum/go-ethereum/ethclient"
    "github.com/learn/init_order/store"
)

const (
    contractAddr = "<deployed contract address>"
)

func main() {
    
	// 连接区块链节点
	client, err := ethclient.Dial("<execution-layer-endpoint-url>")
    if err != nil {
        log.Fatal(err)
    }
    
	// 创建合约实例
	storeContract, err := store.NewStore(common.HexToAddress(contractAddr), client)
    if err != nil {
        log.Fatal(err)
    }

    // 设置私钥
	privateKey, err := crypto.HexToECDSA("<your private key>")
    if err != nil {
        log.Fatal(err)
    }

    // 设置要存储的键值对
	var key [32]byte
    var value [32]byte

    copy(key[:], []byte("demo_save_key"))
    copy(value[:], []byte("demo_save_value11111"))

   	// 调用合约的 SetItem 方法
	// 这里的 ChainID 是 Goerli 测试网的 ID

	// 初始化交易opt实例（交易管理者）
	opt, err := bind.NewKeyedTransactorWithChainID(privateKey, big.NewInt(11155111))
    if err != nil {
        log.Fatal(err)
    }

	// 调用合约的 SetItem 方法
	// 并返回交易实例
    tx, err := storeContract.SetItem(opt, key, value)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println("tx hash:", tx.Hash().Hex())

    // 调用合约的 GetItem 方法，查询合约中的数据并验证
	
	// bind.CallOpts 是 go-ethereum 库中定义的一个结构体，用于配置对以太坊智能合约的调用选项。
	// 它通常用于只读调用（不需要发送交易，仅查询区块链状态）。
	callOpt := &bind.CallOpts{Context: context.Background()}
    valueInContract, err := storeContract.Items(callOpt, key)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println("is value saving in contract equals to origin value:", valueInContract == value)
}

```
