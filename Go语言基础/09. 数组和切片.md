```go
/* 数组（在Go中数组是固定长度）
var a [5]int
var marr [2]map[string]string

// 待定长度（赋值后就会有固定长度）
var a_str [...]string

// 赋值
var arr = [5]int {1, 2, 3, 4, 5}
var arr_length = len(arr)

/* 数组的部分特性类似基础数据类型，当数组作为参数传递时，在函数中并不能改变外部实参的值。

  如果想要修改外部实参的值，需要把数组的指针作为参数传递给函数。

/* 在Go语言中，当传参传入的是指针变量时，
  指针变量会复制一份拷贝进入函数，但指针的值所指向的地址不变。

  即原指针变量与进入函数的指针变量的拷贝，它们两个所占据的内存地址不同，
  但它们所指向的地址相同，所以解引用指向的值相同。


/* 切片（slice）
切片(Slice)并不是数组或者数组指针，而是数组的一个引用。（在Go中，引用不等于指针）
切片本身是一个标准库中实现的一个特殊的结构体，这个结构体中有三个属性，分别代表数组指针、长度、容量。

切片还可以使用 len() 和 cap() 函数访问切片的长度和容量。
长度表示切片可以访问到底层数组的数据范围。（访问权限）
容量表示切片引用的底层数组的长度。
切片的长度小于等于切片的容量。

具体可以查看 golang 源码仓库中 src/runtime/slice.go 文件中：
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}

初始化切片，代码示例：
// 方式1，声明并初始化一个空的切片
var s1 []int = []int{}

// 方式2，类型推导，并初始化一个空的切片
var s2 = []int{}

// 方式3，与方式2等价
s3 := []int{}

// 方式4，与方式1、2、3 等价，可以在大括号中定义切片初始元素
s4 := []int{1, 2, 3, 4}

// 方式5，用make()函数创建切片，创建[]int类型的切片，指定切片初始长度为0
s5 := make([]int, 0)

// 方式6，用make()函数创建切片，创建[]int类型的切片，指定切片初始长度为2，指定容量参数4
s6 := make([]int, 2, 4) 

// 方式7，引用一个数组，初始化切片
a := [5]int{6,5,4,3,2}
// 从数组下标2开始，直到数组的最后一个元素
s7 := arr[2:]
// 从数组下标1开始，直到数组下标3的元素，创建一个新的切片
s8 := arr[1:3]
// 从0到下标2的元素，创建一个新的切片
s9 := arr[:2]

/* 切片添加元素， append函数

s3 := []int{}
fmt.Println("s3 = ", s3)
// append函数追加元素
s3 = append(s3)
s3 = append(s3, 1)
s3 = append(s3, 2, 3)
fmt.Println("s3 = ", s3)
除了使用 append() 函数向切片追加元素以外，还可以使用 append() 向指定位置添加元素，以及移除指定位置的元素。

向指定位置添加元素的代码示例：
s4 := []int{1, 2, 4, 5}
s4 = append(s4[:2], append([]int{3}, s4[2:]...)...)
fmt.Println("s4 = ", s4)
移除指定位置元素代码示例：
s5 := []int{1,2,3,5,4}
s5 = append(s5[:3], s5[4:]...)
fmt.Println("s5 = ", s5)

/* 复制切片，copy函数
copy(a, b)
其中a是被赋值，b是原切片
不过若是a, b长度不同，则不能完全赋值

/* 切片底层原理
切片类型实际上是比较特殊的指针类型，当声明一个切片类型时，就是声明了一个指针。

这个指针指向的切片结构体，切片结构体中记录的三个属性：数组指针、长度、容量。这几个属性在创建一个切片时就定义好，并且在之后都不能再被修改。

所以切片传参后的改动也会影响到原始变量。

/* 切片的变化会影响到其引用到数组，也会影响引用相同数组的其他切片。

/* append函数并不会影响原始的切片。
  什么意思？
  append函数会形成一个新的切片，原来的切片引用，长度和容量不变，新追加的值超过切片可访问范围，访问不到新追加的值。
  新的切片引用，与原始切片引用相比，长度加一，容量不变，可以访问到新追加的值。
  新旧切片的指向数组相同，但是访问权限不同。

  但是，若是append函数出发了切片的扩容：
  当 append() 函数触发扩容后，实际上是新创建了一个数组实例，把原来的数组中的数据复制到了新数组中，然后创建一个新的切片实例并返回。
  这时原始切片中持有的数组指针指向的数组与新切片引用中的数组指针指向的数组是两个不同的数组，修改并不会相互影响。
  即新旧切片指向的数组不同了。

  1. 切片触发扩容前，切片一直共用相同的数组；
  2. 切片触发扩容后，会创建新的数组，并复制这些数据；
  3. 切片本身是一个特殊的指针，go 针对切片类型添加了一些语法糖，方便使用。
```
