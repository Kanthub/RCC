```go
/* Go语言当中没有类的概念
  可以在一个文件中定义多个struct结构体
  Go 中，全局变量、全局常量、结构体、字段、方法，只有两种公开类型，公开与非公开。
  非公开是针对包级别的，也就是说如果全局变量声明在不同的源文件中，但是这些源文件属于相同的包，那么这些中的代码可以引用这些不公开的全局变量。
  不属于相同的包就访问不到了。并且公开的属性是首字母大写，非公开的属性首字母是小写，仅按照这个规则来定义是否公开。

/* 定义结构体：type <name> struct {}

  type Person struct {
    Name  string
    Age   int
    Call  func() byte
    Map   map[string]string
    Ch    chan string
    Arr   [32]uint8
    Slice []interface{}
    Ptr   *int
    once  sync.Once

}

/* 结构体中定义匿名字段
  type <Name> struct {
    <type1>
    <type2>
    <type3>
  }

  type Custom struct {
      int
      string
      Str string
      Price int
  }
  注意：在go语言的结构体中，匿名字段的类型名级别可以上升，上升为变量名级别。
        意思是结构体可以直接通过变量名索引字段。
  example.
    var suit Custom = Custom {8, "abc", "xyz", 9}
    suit.int = 10
    suit.string = "def"
    suit.Str = "mnk"
    suit.Price = 20


/* 匿名结构体
  var <var name> = struct {
    <FiledName1> <type1> `<tag1>:"<any string>"`
    <FiledName2> <type2> `<tag2>:"<any string>"`
    ...
    <type3>
    <type4>
    ...
  } {
    <FiledName1>: <value1>,
    <FiledName2>: <value2>,
    ...
    <type3>: <value3>,
    <type4>: <value4>,
  }
  注意：匿名结构体必须初始化{}

  在函数或方法中声明匿名结构体并实例化：
  func method() {
    <var name> := struct {
        <FieldName1> <type1>
        <FieldName2> <type2>
        ...
        <type3>
        <type4>
    } {
        <FieldName1>: <value1>,
        <FieldName2>: <value2>,

        <type3>: <value3>,
        <type4>: <value4>,
    }
  }


/* 嵌套结构体
  type A struct {
    a string
  }

type B struct {
    A
    b string
  }

type C struct {
    A
    B
    a string
    b string
    c string
  }
  访问可以使用类似语句：
  var aa = A {}
  var bb = B {}
  var cc = C {}
  aa.a
  bb.A.a
  cc.A.a
  cc.B.A.a

/* 结构体方法
Go 中没有方法重写的规则，即不允许相同名称的方法存在，即使方法的参数不同。（方法严格不能重名）
Go 中，结构体类型的变量和结构体类型指针的变量都可以直接访问结构体中声明的字段和调用声明的方法。（A, *A方法可以被a, &a混用）
  
```
